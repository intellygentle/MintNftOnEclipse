import { Serializer } from '@metaplex-foundation/umi/serializers';
import { And } from './and';
import { Not } from './not';
import { Or } from './or';
import { OwnedBy } from './ownedBy';
import { PubkeyMatch } from './pubkeyMatch';
import { Empty } from './empty';
export * from './and';
export * from './empty';
export * from './not';
export * from './or';
export * from './ownedBy';
export * from './pubkeyMatch';
export type Constraint = And | Not | Or | OwnedBy | PubkeyMatch | Empty;
export declare const getConstraintSerializer: () => Serializer<Constraint>;
export declare const getConstraintSerializerFromType: <T extends Constraint>(type: T["type"]) => Serializer<T, T>;
export declare enum OperatorType {
    And = 0,
    Not = 1,
    Or = 2,
    OwnedBy = 3,
    PubkeyMatch = 4,
    Empty = 5
}
export type OperatorTypeArgs = OperatorType;
export declare function getOperatorTypeSerializer(): Serializer<OperatorTypeArgs, OperatorType>;
export type ConstraintHeader = {
    type: number;
    size: number;
};
export declare const getConstraintHeaderSerializer: () => Serializer<ConstraintHeader>;
export declare const wrapSerializerInConstraintHeader: <T extends {
    type: string;
}>(type: OperatorType, serializer: Serializer<Omit<T, "type">, Omit<T, "type">>) => Serializer<T, T>;
export declare const getOperatorTypeAsString: (type: OperatorType) => Constraint['type'];
export type Account = 'Asset' | 'Authority' | 'Recipient';
export declare function getAccountSerializer(): Serializer<Account>;
