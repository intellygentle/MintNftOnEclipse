"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAccountSerializer = exports.getOperatorTypeAsString = exports.wrapSerializerInConstraintHeader = exports.getConstraintHeaderSerializer = exports.getOperatorTypeSerializer = exports.OperatorType = exports.getConstraintSerializerFromType = exports.getConstraintSerializer = void 0;
/* eslint-disable @typescript-eslint/no-shadow */
const serializers_1 = require("@metaplex-foundation/umi/serializers");
const and_1 = require("./and");
const not_1 = require("./not");
const or_1 = require("./or");
const ownedBy_1 = require("./ownedBy");
const pubkeyMatch_1 = require("./pubkeyMatch");
const empty_1 = require("./empty");
__exportStar(require("./and"), exports);
__exportStar(require("./empty"), exports);
__exportStar(require("./not"), exports);
__exportStar(require("./or"), exports);
__exportStar(require("./ownedBy"), exports);
__exportStar(require("./pubkeyMatch"), exports);
const getConstraintSerializer = () => ({
    description: 'Constraint',
    fixedSize: null,
    maxSize: null,
    serialize: (constraint) => (0, exports.getConstraintSerializerFromType)(constraint.type).serialize(constraint),
    deserialize: (buffer, offset = 0) => {
        const type = buffer[offset];
        const typeAsString = (0, exports.getOperatorTypeAsString)(type);
        return (0, exports.getConstraintSerializerFromType)(typeAsString).deserialize(buffer, offset);
    },
});
exports.getConstraintSerializer = getConstraintSerializer;
const getConstraintSerializerFromType = (type) => (() => {
    switch (type) {
        case 'And':
            return (0, and_1.getAndSerializer)();
        case 'Not':
            return (0, not_1.getNotSerializer)();
        case 'Or':
            return (0, or_1.getOrSerializer)();
        case 'OwnedBy':
            return (0, ownedBy_1.getOwnedBySerializer)();
        case 'PubkeyMatch':
            return (0, pubkeyMatch_1.getPubkeyMatchSerializer)();
        case 'Empty':
            return (0, empty_1.getEmptySerializer)();
        default:
            throw new Error(`Unknown operator type: ${type}`);
    }
})();
exports.getConstraintSerializerFromType = getConstraintSerializerFromType;
// -------------------//
// OperatorType       //
// -------------------//
var OperatorType;
(function (OperatorType) {
    OperatorType[OperatorType["And"] = 0] = "And";
    OperatorType[OperatorType["Not"] = 1] = "Not";
    OperatorType[OperatorType["Or"] = 2] = "Or";
    OperatorType[OperatorType["OwnedBy"] = 3] = "OwnedBy";
    OperatorType[OperatorType["PubkeyMatch"] = 4] = "PubkeyMatch";
    OperatorType[OperatorType["Empty"] = 5] = "Empty";
})(OperatorType = exports.OperatorType || (exports.OperatorType = {}));
function getOperatorTypeSerializer() {
    return (0, serializers_1.scalarEnum)(OperatorType, {
        description: 'OperatorType',
        size: (0, serializers_1.u32)(),
    });
}
exports.getOperatorTypeSerializer = getOperatorTypeSerializer;
const getConstraintHeaderSerializer = () => (0, serializers_1.struct)([
    ['type', (0, serializers_1.u32)()],
    ['size', (0, serializers_1.u32)()],
]);
exports.getConstraintHeaderSerializer = getConstraintHeaderSerializer;
const wrapSerializerInConstraintHeader = (type, serializer) => {
    const HEADER_SIZE = 8; // 8 bytes for the constraint header
    const typeAsString = (0, exports.getOperatorTypeAsString)(type);
    const headerSerializer = (0, exports.getConstraintHeaderSerializer)();
    return {
        description: typeAsString,
        fixedSize: serializer.fixedSize === null ? null : serializer.fixedSize + HEADER_SIZE,
        maxSize: serializer.maxSize === null ? null : serializer.maxSize + HEADER_SIZE,
        serialize: (constraint) => {
            const serializedConstaint = serializer.serialize(constraint);
            const serializedHeader = headerSerializer.serialize({
                type,
                size: serializedConstaint.length,
            });
            return (0, serializers_1.mergeBytes)([serializedHeader, serializedConstaint]);
        },
        deserialize: (buffer, offset = 0) => {
            const [header] = headerSerializer.deserialize(buffer, offset);
            offset += HEADER_SIZE;
            const slice = buffer.slice(offset, offset + header.size);
            const [constraint] = serializer.deserialize(slice);
            return [{ ...constraint, type: typeAsString }, offset + header.size];
        },
    };
};
exports.wrapSerializerInConstraintHeader = wrapSerializerInConstraintHeader;
const getOperatorTypeAsString = (type) => {
    switch (type) {
        case OperatorType.And:
            return 'And';
        case OperatorType.Not:
            return 'Not';
        case OperatorType.Or:
            return 'Or';
        case OperatorType.OwnedBy:
            return 'OwnedBy';
        case OperatorType.PubkeyMatch:
            return 'PubkeyMatch';
        case OperatorType.Empty:
            return 'Empty';
        default:
            throw new Error(`Unknown operator type: ${type}`);
    }
};
exports.getOperatorTypeAsString = getOperatorTypeAsString;
// -------------------//
// Account            //
// -------------------//
var AccountType;
(function (AccountType) {
    AccountType[AccountType["Asset"] = 0] = "Asset";
    AccountType[AccountType["Authority"] = 1] = "Authority";
    AccountType[AccountType["Recipient"] = 2] = "Recipient";
})(AccountType || (AccountType = {}));
function getAccountSerializer() {
    return (0, serializers_1.mapSerializer)((0, serializers_1.scalarEnum)(AccountType, {
        size: (0, serializers_1.u64)(),
    }), (account) => AccountType[account], (accountType) => AccountType[accountType]);
}
exports.getAccountSerializer = getAccountSerializer;
//# sourceMappingURL=index.js.map