import { Serializer } from '@metaplex-foundation/umi/serializers';
import { TypedExtension } from '.';
import { Asset } from '..';
import { Type } from '../generated';
type Property = Omit<Text, 'type'> | Omit<Number, 'type'> | Omit<Boolean, 'type'>;
export declare const properties: (values: Property[]) => TypedExtension;
type TypedPropertyfromEnum<T extends Type> = Extract<TypedProperty, {
    type: T;
}>;
export declare function getProperty<T extends Type>(asset: Asset, name: string, type: T): TypedPropertyfromEnum<T> | undefined;
export type Properties = {
    values: Array<TypedProperty>;
};
export type PropertiesArgs = {
    values: Array<TypedProperty>;
};
export declare function getPropertiesSerializer(): Serializer<PropertiesArgs, Properties>;
export declare const getPropertySerializer: () => Serializer<TypedProperty>;
export type TypedProperty = ({
    type: Type.Text;
} & Omit<Text, 'type'>) | ({
    type: Type.Number;
} & Omit<Number, 'type'>) | ({
    type: Type.Boolean;
} & Omit<Boolean, 'type'>);
export declare const getPropertySerializerFromType: <T extends TypedProperty>(type: Type) => Serializer<T, T>;
export declare const getTypeFromString: (type: String) => Type;
export type Text = {
    name: string;
    type: Type;
    value: string;
};
export type TextArgs = Text;
export declare function getTextSerializer(): Serializer<TextArgs, Text>;
export type Number = {
    name: string;
    type: Type;
    value: bigint;
};
export type NumberArgs = Number;
export declare function getNumberSerializer(): Serializer<NumberArgs, Number>;
export type Boolean = {
    name: string;
    type: Type;
    value: boolean;
};
export type BooleanArgs = Boolean;
export declare function getBooleanSerializer(): Serializer<BooleanArgs, Boolean>;
export {};
