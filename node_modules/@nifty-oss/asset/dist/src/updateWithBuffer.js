"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateWithBuffer = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const _1 = require(".");
const extensions_1 = require("./extensions");
const allocate_1 = require("./generated/instructions/allocate");
const update_1 = require("./generated/instructions/update");
const write_1 = require("./write");
function updateWithBuffer(context, input) {
    const data = (0, extensions_1.getExtensionSerializerFromType)(input.extension.type).serialize(input.extension);
    const chunked = data.length > (input.chunkSize ?? write_1.DEFAULT_CHUNK_SIZE);
    if (input.proxy) {
        const proxied = context.programs.clone();
        proxied.bind('asset', input.proxy);
        context = { ...context, programs: proxied };
    }
    if (chunked) {
        const buffer = (0, umi_1.generateSigner)(context);
        let updateIx = (0, update_1.update)(context, {
            ...input,
            buffer: buffer.publicKey,
            systemProgram: _1.SYSTEM_PROGRAM_ID,
            extension: (0, umi_1.none)(),
        });
        if (input.proxy) {
            updateIx = updateIx.addRemainingAccounts({
                pubkey: _1.ASSET_PROGRAM_ID,
                isWritable: false,
                isSigner: false,
            });
        }
        return (0, write_1.write)(context, {
            ...input,
            asset: buffer,
            data,
        })
            .prepend((0, allocate_1.allocate)(context, {
            ...input,
            asset: buffer,
            extension: {
                extensionType: input.extension.type,
                length: data.length,
                data: null,
            },
        }))
            .append(updateIx)
            .append((0, _1.close)(context, {
            buffer,
            recipient: input.payer?.publicKey ?? context.payer.publicKey,
        }));
    }
    let updateIx = (0, update_1.update)(context, {
        ...input,
        extension: {
            extensionType: input.extension.type,
            length: data.length,
            data,
        },
    });
    if (input.proxy) {
        updateIx = updateIx.addRemainingAccounts({
            pubkey: _1.ASSET_PROGRAM_ID,
            isWritable: false,
            isSigner: false,
        });
    }
    return (0, umi_1.transactionBuilderGroup)([updateIx]);
}
exports.updateWithBuffer = updateWithBuffer;
//# sourceMappingURL=updateWithBuffer.js.map